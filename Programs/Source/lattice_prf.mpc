#TODO Remove Z2N support?

### Lattice PRF
# Run with one of the following commands:
# BASE_RING=Z2N ./Scripts/compile-run.py -O -E mal-rep-ring -R 12 lattice_prf
# BASE_RING=GFP ./Scripts/compile-run.py -O -E mal-shamir -F 32 -g 256 lattice_prf
#
# For separate preprocessing:
# BASE_RING=Z2N ./compile.py -O -R 12 lattice_prf && ./Fake-Offline.x 3 -lgp 12 && ./Scripts/mal-rep-ring.sh -F lattice_prf
# BASE_RING=GFP ./compile.py -O -F 32 lattice_prf && ./Scripts/mal-shamir-offline.sh -lgp 256 lattice_prf && ./Scripts/mal-shamir.sh -F lattice_prf
#
# As a single command:
# BASE_RING=GFP ./Scripts/run-lattice-prf.sh
#
# Adjusting parameters:
# LOG2Q=12 LOG2P=8 INT_SIZE=32 BASE_RING=GFP KEYGEN=0 COMPOSE=1 ./Scripts/run-lattice-prf.sh
# LOG2Q=32 LOG2P=24 INT_SIZE=72 BASE_RING=GFP KEYGEN=0 COMPOSE=1 ./Scripts/run-lattice-prf.sh

import os
from random import randint

from Compiler.types import *
from Compiler.library import print_ln

from enum import Enum

class BaseRing(Enum):
    Z2N = "Z2N"
    GFP = "GFP"

    @staticmethod
    def parse(s: str):
        if s == BaseRing.Z2N.value:
            return BaseRing.Z2N
        elif s == BaseRing.GFP.value:
            return BaseRing.GFP
        raise Exception(f"Parameter {s} is not a valid base ring!")

def raise_ring_unsupported():
    raise Exception(f"BASE_RING {BASE_RING} unsupported!")

def parse_bool(s: str) -> bool:
    return bool(int(s))

BASE_RING = BaseRing.parse(os.environ.get("BASE_RING", "GFP"))
BITS = int(os.environ.get("BITS", 256)) # Number of random bits to produce.
KEYGEN = parse_bool(os.environ.get("KEYGEN", False)) # Run key generation.
COMPOSE = parse_bool(os.environ.get("COMPOSE", True)) # Compose PRF output into single base ring element.
REVEAL = parse_bool(os.environ.get("REVEAL", False)) # Reval output.
LOG2Q = int(os.environ.get("LOG2Q", 12))
LOG2P = int(os.environ.get("LOG2P", 8))
OPTIMIZE = parse_bool(os.environ.get("OPTIMIZE", False)) # Enable optimization.
DOUBLE = parse_bool(os.environ.get("DOUBLE", False)) # Run evaluation twice.

if OPTIMIZE and BASE_RING != BaseRing.GFP:
    raise Exception("OPTIMIZE only supported for GFP!")

log2q, log2p = LOG2Q, LOG2P
# log2q, log2p = 12, 8
# log2q, log2p = 32, 24
m = 512
l = BITS // log2p

if COMPOSE:
    # Compute how many p-bit values we need to generate a random element in the
    # base ring.
    stat = 40 # statistical distance
    l = math.ceil((BITS + stat) / log2p) # number of p-bit values

print(f"ring={BASE_RING.value}, q=2^{log2q}, p=2^{log2p}, m={m}, l={l}")
print(f"KEYGEN={KEYGEN}, COMPOSE={COMPOSE}, REVEAL={REVEAL}, OPTIMIZE={OPTIMIZE}")

def crand():
    r = randint(0, 2**log2q-1)
    if BASE_RING == BaseRing.Z2N:
        return cint(r)
    elif BASE_RING == BaseRing.GFP:
        return cint(r)
    raise_ring_unsupported()

def srand():
    if BASE_RING == BaseRing.Z2N:
        return sint.get_random()
    elif BASE_RING == BaseRing.GFP:
        return sint.get_random_int(log2q)
    raise_ring_unsupported()

def ctype():
    if BASE_RING == BaseRing.Z2N:
        return cint
    elif BASE_RING == BaseRing.GFP:
        return cint
    raise_ring_unsupported()

def stype():
    if BASE_RING == BaseRing.Z2N:
        return sint
    elif BASE_RING == BaseRing.GFP:
        return sint
    raise_ring_unsupported()

def mod(s: sint):
    """Modulo q."""
    if BASE_RING == BaseRing.Z2N:
        return s # already mod 2^log2q
    elif BASE_RING == BaseRing.GFP:
        return s.mod2m(log2q)
    raise_ring_unsupported()

def round(s: sint):
    """Round to nearest p-bit value."""
    if BASE_RING == BaseRing.Z2N:
        return s.right_shift(log2q - log2p)
    elif BASE_RING == BaseRing.GFP:
        return s.right_shift(log2q - log2p)
    raise_ring_unsupported()

def compose(a: Array) -> sint:
    l = len(a)
    if BASE_RING == BaseRing.Z2N:
        return sum(a[i] << (i*log2p % log2q) for i in range(l))
    elif BASE_RING == BaseRing.GFP:
        return sum(a[i] << i*log2p for i in range(l))
    raise_ring_unsupported()

def key_gen(m: int):
    a = Matrix(l, m, ctype())
    for i in range(l):
        for j in range(m):
            a[i][j] = crand()

    k = Array(m, stype())
    for i in range(m):
        if KEYGEN:
            k[i] = srand()
        else:
            k[i] = stype()(crand())
    return a, k

def eval(a: Matrix, k: Array):
    r = a * k
    if OPTIMIZE:
        # Instead of rounding each element of `r` at the top and the bottom, we
        # only round the bottom and top of the vector and then compose the
        # elements such that the uniform bits overlap (and therefore hide) the
        # non-uniform bits.
        
        # Cut off top bits. `n_top` is the number of elements from which we need
        # to cut off the top bits in order to hide the top bits of the preceding
        # element.
        top_bits = log2q + l.bit_length()
        n_top = top_bits // log2p + 1
        for i in range(n_top):
            r[-i-1] = r[-i-1].mod2m(log2q)
        
        # Cut off bottom bits. `n_bot` is the number of elements from which we
        # need to cut off the bottom bits in order to hide the bottom bits of
        # the next element.
        bot_bits = log2q - log2p
        n_bot = bot_bits // log2p + 1
        for i in range(n_bot):
            r[i] = r[i].right_shift(log2q - log2p)

        # Compose the elements into one uniform random value by layering uniform
        # bits on top of non-uniform bits. Account for the fact the bottom bits
        # of the elements starting from `n_bot` are not cut off.
        r = sum(
            ri << i*log2p - (0 if i<n_bot else log2q-log2p)
            for i, ri in enumerate(r))
    else:
        for i in range(l):
            r[i] = round(mod(r[i]))
        if COMPOSE:
            r = compose(r)
    return r

def main():    
    a, k = key_gen(m)
    r = eval(a, k)
    if DOUBLE:
        r = eval(a, k)
    if REVEAL:
        print_ln("output = %s", r.reveal())

main()
