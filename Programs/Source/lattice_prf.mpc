### Lattice PRF
# Run with one of the following commands:
# BASE_RING=Z2N ./Scripts/compile-run.py -E mal-rep-ring -R 12 lattice_prf
# BASE_RING=GFP ./Scripts/compile-run.py -E mal-shamir -F 256 lattice_prf
#
# For separate preprocessing:
# BASE_RING=Z2N ./compile.py -R 12 lattice_prf && ./Fake-Offline.x 3 -lgp 12 && ./Scripts/mal-rep-ring.sh -F lattice_prf
# BASE_RING=GFP ./compile.py -F 256 lattice_prf && ./Scripts/mal-shamir-offline.sh lattice_prf && ./Scripts/mal-shamir.sh -F lattice_prf
#
# As a single command:
# BASE_RING=GFP ./Scripts/run-lattice-prf.sh
#
# Setting parameters:
# LOG2Q=12 LOG2P=8 BIT_LENGTH=32 BASE_RING=GFP KEYGEN=0 COMPOSE=1 ./Scripts/run-lattice-prf.sh
# LOG2Q=32 LOG2P=24 BIT_LENGTH=72 BASE_RING=GFP KEYGEN=0 COMPOSE=1 ./Scripts/run-lattice-prf.sh

import os
from random import randint

from Compiler import program
from Compiler.types import *
from Compiler.library import print_ln

from enum import Enum

class BaseRing(Enum):
    Z2N = "Z2N"
    GFP = "GFP"

    @staticmethod
    def parse(s: str):
        if s == BaseRing.Z2N.value:
            return BaseRing.Z2N
        elif s == BaseRing.GFP.value:
            return BaseRing.GFP
        raise Exception(f"Parameter {s} is not a valid base ring!")

def raise_ring_unsupported():
    raise Exception(f"BASE_RING {BASE_RING} unsupported!")

def parse_bool(s: str) -> bool:
    return bool(int(s))

BASE_RING = BaseRing.parse(os.environ.get("BASE_RING", "GFP"))
BITS = int(os.environ.get("BITS", 256)) # Number of random bits to produce.
KEYGEN = parse_bool(os.environ.get("KEYGEN", True)) # Run key generation.
COMPOSE = parse_bool(os.environ.get("COMPOSE", False)) # Compose PRF output into single base ring element.
REVEAL = parse_bool(os.environ.get("REVEAL", False)) # Reval output.
LOG2Q = int(os.environ.get("LOG2Q", 12))
LOG2P = int(os.environ.get("LOG2P", 8))

log2q, log2p = LOG2Q, LOG2P
# log2q, log2p = 12, 8
# log2q, log2p = 32, 24
m = 256
l = BITS // log2p

if COMPOSE:
    # Compute how many p-bit values we need to generate a random element in the
    # base ring.
    stat = 40 # statistical distance
    l = (BITS + stat) // log2p # number of p-bit values

print(f"ring={BASE_RING.value}, q=2^{log2q}, p=2^{log2p}, m={m}, l={l}")
print(f"KEYGEN={KEYGEN}, COMPOSE={COMPOSE}, REVEAL={REVEAL}")

def crand():
    r = randint(0, 2**log2q-1)
    if BASE_RING == BaseRing.Z2N:
        return cint(r)
    elif BASE_RING == BaseRing.GFP:
        return cint(r)
    raise_ring_unsupported()

def srand():
    if BASE_RING == BaseRing.Z2N:
        return sint.get_random()
    elif BASE_RING == BaseRing.GFP:
        return sint.get_random_int(log2q)
    raise_ring_unsupported()

def ctype():
    if BASE_RING == BaseRing.Z2N:
        return cint
    elif BASE_RING == BaseRing.GFP:
        return cint
    raise_ring_unsupported()

def stype():
    if BASE_RING == BaseRing.Z2N:
        return sint
    elif BASE_RING == BaseRing.GFP:
        return sint
    raise_ring_unsupported()

def round(s: sint):
    if BASE_RING == BaseRing.Z2N:
        return s.right_shift(log2q - log2p)
    elif BASE_RING == BaseRing.GFP:
        return s.mod2m(log2q).right_shift(log2q - log2p)
    raise_ring_unsupported()

def compose(a: Array) -> sint:
    l = len(a)
    if BASE_RING == BaseRing.Z2N:
        return sum(a[i] << (i*log2p % log2q) for i in range(l))
    elif BASE_RING == BaseRing.GFP:
        return sum(a[i] << i*log2p for i in range(l))
    raise_ring_unsupported()

def key_gen(m: int):
    a = Matrix(l, m, ctype())
    for i in range(l):
        for j in range(m):
            a[i][j] = crand()

    k = Array(m, stype())
    for i in range(m):
        if KEYGEN:
            k[i] = srand()
        else:
            k[i] = stype()(crand())
    return a, k

def eval(a: Matrix, k: Array):
    r = a * k
    for i in range(l):
        r[i] = round(r[i])
    if COMPOSE:
        r = compose(r)
    return r

def main():    
    a, k = key_gen(m)
    r = eval(a, k)
    if REVEAL:
        print_ln("output = %s", r.reveal())

main()
