### Lattice PRF
# Run with one of the following commands:
# BASE_RING=GF2N ./Scripts/compile-run.py -E mal-shamir -g 12 lattice_prf
# BASE_RING=Z2N ./Scripts/compile-run.py -E mal-rep-ring -R 12 lattice_prf
# BASE_RING=ZP ./Scripts/compile-run.py -E mal-shamir -F 256 lattice_prf
#
# For separate preprocessing, run one of the following:
# BASE_RING=GF2N ./compile.py -g 12 lattice_prf && ./Scripts/mal-shamir-offline.sh lattice_prf && ./Scripts/mal-shamir.sh -F lattice_prf
# BASE_RING=ZP ./compile.py -F 256 lattice_prf && ./Scripts/mal-shamir-offline.sh lattice_prf && ./Scripts/mal-shamir.sh -F lattice_prf

import os
from random import randint

from Compiler import program
from Compiler.types import *
from Compiler.library import print_ln

from enum import Enum

class BaseRing(Enum):
    GF2N = 1
    Z2N = 2
    ZP = 3

    @staticmethod
    def parse(s: str):
        if s == "GF2N":
            return BaseRing.GF2N
        elif s == "Z2N":
            return BaseRing.Z2N
        elif s == "ZP":
            return BaseRing.ZP
        raise Exception(f"Parameter {s} is not a valid base ring!")

def raise_ring_unsupported():
    raise Exception(f"BASE_RING {BASE_RING} unsupported!")

BASE_RING_VAL = os.environ.get("BASE_RING", "GF2N")
BASE_RING = BaseRing.parse(BASE_RING_VAL)
n = 20
log2q = 12
log2p = 8
m = n * log2q
l = program.bit_length // log2p

print(f"base={BASE_RING_VAL}, m={m}, q=2^{log2q}, p=2^{log2p}")

def crand():
    r = randint(0, 2**log2q-1)
    if BASE_RING == BaseRing.GF2N:
        return cgf2n(r)
    elif BASE_RING == BaseRing.Z2N:
        return cint(r)
    elif BASE_RING == BaseRing.ZP:
        return cint(r)
    raise_ring_unsupported()

def srand():
    if BASE_RING == BaseRing.GF2N:
        return sgf2n.get_random_triple()[0]
    elif BASE_RING == BaseRing.Z2N:
        return sint.get_random()
    elif BASE_RING == BaseRing.ZP:
        return sint.get_random_int(log2q)
    raise_ring_unsupported()

def ctype():
    if BASE_RING == BaseRing.GF2N:
        return cgf2n
    elif BASE_RING == BaseRing.Z2N:
        return cint
    elif BASE_RING == BaseRing.ZP:
        return cint
    raise_ring_unsupported()

def stype():
    if BASE_RING == BaseRing.GF2N:
        return sgf2n
    elif BASE_RING == BaseRing.Z2N:
        return sint
    elif BASE_RING == BaseRing.ZP:
        return sint
    raise_ring_unsupported()

def round(s: sint):
    if BASE_RING == BaseRing.GF2N:
        return s.right_shift(log2q - log2p)
    elif BASE_RING == BaseRing.Z2N:
        return s.right_shift(log2q - log2p)
    elif BASE_RING == BaseRing.ZP:
        return s.mod2m(log2q).right_shift(log2q - log2p)
    raise_ring_unsupported()

def key_gen(m: int):
    a = Matrix(l, m, ctype())
    for i in range(l):
        for j in range(m):
            a[i][j] = crand()

    k = Array(m, stype())
    for i in range(m):
        k[i] = srand()
    return a, k

def eval(a: Matrix, k: Array):
    r = a * k
    for i in range(l):
        r[i] = round(r[i])
    r = sum(2**(i*log2p) * r[i] for i in range(l))
    return r

def main():    
    a, k = key_gen(m)
    r = eval(a, k)
    print_ln("output = %s", r.reveal())

main()
