### Lattice PRF
#
# Compile and run:
#   PROG=lattice_prf && ./Scripts/compile-run.py -O -E mal-shamir -g 256 $PROG
#
# Compile and run with separate preprocessing:
#   PROG=lattice_prf && ./compile.py -O -g 256 $PROG && ./Scripts/mal-shamir-offline.sh -lgp 256 $PROG && ./Scripts/mal-shamir.sh -F $PROG
#
# Compile and run with a single command and adjusted parameters:
#   PROG=lattice_prf LOG2Q=12 LOG2P=8 ./Scripts/run-lattice-prf.sh
#   PROG=lattice_prf LOG2Q=32 LOG2P=24 ./Scripts/run-lattice-prf.sh
#   PROG=lattice_prf LOG2Q=64 LOG2P=56 ./Scripts/run-lattice-prf.sh
#
# Measure total communication:
#   PROG=lattice_prf && LOG2Q=12 LOG2P=8 ./Scripts/compile-run.py -O -E mal-shamir -g 256 $PROG -- --batch-size 100

import os
from random import randint

from Compiler.types import *
from Compiler.library import print_ln
from Compiler.comparison import PRandM, BitLTL

def parse_bool(s: str) -> bool:
    return bool(int(s))

BITS = int(os.environ.get("BITS", 256)) # Number of random bits to produce.
KEYGEN = parse_bool(os.environ.get("KEYGEN", False)) # Run key generation.
REVEAL = parse_bool(os.environ.get("REVEAL", False)) # Reval output.
LOG2Q = int(os.environ.get("LOG2Q", 12)) # Lattice modulus bitlength.
LOG2P = int(os.environ.get("LOG2P", 8)) # Rounding modulus bitlength.
DIM = int(os.environ.get("DIM", 512)) # Lattice dimension.
DOUBLE = parse_bool(os.environ.get("DOUBLE", False)) # Run evaluation twice.

log2q = LOG2Q # Lattice modulus.
log2p = LOG2P # Rounding modulus.
m = DIM # Lattice dimension
int_size = ((2**log2q - 1)**2 * m).bit_length() # Maximum integer size.

# Compute how many p-bit elements we need to generate a random element in the
# base ring.
kappa = program.security # Controls the statistical distance to the uniform distribution.
l = math.ceil((BITS + kappa) / log2p) # Number of p-bit elements required to fill up the target range.

if DOUBLE:
    l *= 2

print(f"q=2^{log2q}, p=2^{log2p}, m={m}, l={l}")
print(f"KEYGEN={KEYGEN}, REVEAL={REVEAL}, DOUBLE={DOUBLE}")

def crand():
    r = randint(0, 2**log2q-1)
    return cint(r)

def srand():
    return sint.get_random_int(log2q)

def trunc(a: sint, k: int, m1: int, m2: int) -> sint:
    """
    Truncate the top and bottom bits of the `k`-bit integer `a`. Returns the
    integer corresponding to the bits in the range `[m1:m2]`.
    """
    r_dprime, r_prime, r = sint(), sint(), [sint() for i in range(m2)]
    PRandM(r_dprime, r_prime, r, k, m2, kappa)
    c = (two_power(k-1) + a + two_power(m2) * r_dprime + r_prime).reveal()
    # Compute separate c_prime for m1 and m2.
    c1_prime, c2_prime = c % two_power(m1), c % two_power(m2)
    u1, u2 = sint(), sint()
    BitLTL(u1, c1_prime, r[:m1], kappa), BitLTL(u2, c2_prime, r, kappa)
    a1_prime, a2_prime = c1_prime - sint.bit_compose(r[:m1]) + two_power(m1) * u1, c2_prime - r_prime + two_power(m2) * u2
    return (a2_prime - a1_prime) / two_power(m1)

def compose(a: Array) -> sint:
    l = len(a)
    log2_p1 = log2q - log2p
    log2_p2 = 2 * log2p - log2q
    def shift(i):
        p1_shift = (i - 1) * log2_p1
        p2_shift = i * log2_p2
        return max(0, p1_shift + p2_shift)
    return sum(a[i] << shift(i) for i in range(l))

def key_gen(m: int) -> (Array, Matrix):
    a = Matrix(l, m, cint)
    for i in range(l):
        for j in range(m):
            a[i][j] = crand()
            
    k = Array(m, sint)
    for i in range(m):
        k[i] = srand() if KEYGEN else sint(crand())
    
    return a, k

def eval(a: Matrix, k: Array):
    r = a * k
    
    # Modulo q and round p.
    for i in range(l):
        r[i] = trunc(r[i], int_size, log2q-log2p, log2q)
    
    if DOUBLE:
        l_half = l//2
        
        # Compose.
        r = [
            compose(r[:l_half]),
            compose(r[l_half:]),
        ]
    else:        
        # Compose.
        r = compose(r)
    
    return r

def main():    
    a, k = key_gen(m)
    r = eval(a, k)
    if REVEAL:
        print_ln("output = %s", r.reveal())

main()
