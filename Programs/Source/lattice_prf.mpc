### Lattice PRF
# Run with one of the following commands:
# BASE_RING=GF2N ./Scripts/compile-run.py -E mal-shamir -g 12 lattice_prf
# BASE_RING=Z2N ./Scripts/compile-run.py -E mal-rep-ring -R 12 lattice_prf
#
# For separate preprocessing over GF2N, run the following:
# BASE_RING=GF2N ./compile.py -g 12 lattice_prf
# ./Scripts/mal-shamir-offline.sh lattice_prf
# ./Scripts/mal-shamir.sh -F lattice_prf

import os
from random import randint

from Compiler import program
from Compiler.types import *
from Compiler.library import for_range, print_ln

from enum import Enum

class BaseRing(Enum):
    GF2N = 1
    Z2N = 2
    @staticmethod
    def parse(s: str):
        if s == "GF2N":
            return BaseRing.GF2N
        elif s == "Z2N":
            return BaseRing.Z2N
        raise Exception(f"Paremeter {s} is not a valid base ring!")

def raise_ring_unsupported():
    raise Exception(f"BASE_RING {BASE_RING} unsupported!")

def bit_length():
    if BASE_RING == BaseRing.GF2N:
        return program.galois_length
    elif BASE_RING == BaseRing.Z2N:
        # program.bit_length, for some reason, returns ring_size - 1, which is
        # not what we want. Using program.non_linear.ring_size instead.
        return program.non_linear.ring_size
    raise_ring_unsupported()

BASE_RING_VAL = os.environ.get("BASE_RING", "GF2N")
BASE_RING = BaseRing.parse(BASE_RING_VAL)
n = 20
log2q = bit_length() # 12
log2p = 8
m = n * log2q

print(f"base={BASE_RING_VAL}, m={m}, q=2^{log2q}, p=2^{log2p}")

def crand():
    l = bit_length()
    r = randint(0, 2**l-1)
    if BASE_RING == BaseRing.GF2N:
        return cgf2n(r)
    elif BASE_RING == BaseRing.Z2N:
        return cint(r)
    raise_ring_unsupported()

def srand():
    if BASE_RING == BaseRing.GF2N:
        return sgf2n.get_random_triple()[0]
    elif BASE_RING == BaseRing.Z2N:
        return sint.get_random()
    raise_ring_unsupported()

def ctype():
    if BASE_RING == BaseRing.GF2N:
        return cgf2n
    elif BASE_RING == BaseRing.Z2N:
        return cint
    raise_ring_unsupported()

def stype():
    if BASE_RING == BaseRing.GF2N:
        return sgf2n
    elif BASE_RING == BaseRing.Z2N:
        return sint
    raise_ring_unsupported()

def key_gen(m: int):
    a = Matrix(m, m, ctype())
    for i in range(m):
        for j in range(m):
            a[i][j] = crand()

    k = Array(m, stype())
    @for_range(m)
    def f(i):
        k[i] = srand()
    return a, k

def eval(a: Matrix, k: Array, log2q: int, log2p: int):
    r = sum(a * k)
    return r.right_shift(log2q - log2p)

def main():    
    a, k = key_gen(m)
    r = eval(a, k, log2q, log2p)
    print_ln("output = %s", r.reveal())

main()
