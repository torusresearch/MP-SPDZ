### Lattice PRF
#
# Compile and run:
#   PROG=lattice_prf && ./Scripts/compile-run.py -O -E mal-shamir -g 256 $PROG
#
# Compile and run with separate preprocessing:
#   PROG=lattice_prf && ./compile.py -O -g 256 $PROG && ./Scripts/mal-shamir-offline.sh -lgp 256 $PROG && ./Scripts/mal-shamir.sh -F -lgp 256 $PROG
#
# Compile and run with a single command and adjusted parameters:
#   PROG=lattice_prf LOG2Q=12 LOG2P=8 ./Scripts/run-lattice-prf.sh
#   PROG=lattice_prf LOG2Q=32 LOG2P=24 ./Scripts/run-lattice-prf.sh
#   PROG=lattice_prf LOG2Q=64 LOG2P=56 ./Scripts/run-lattice-prf.sh
#
# Measure total communication:
#   PROG=lattice_prf && LOG2Q=12 LOG2P=8 ./Scripts/compile-run.py -O -E mal-shamir -g 256 $PROG -- --batch-size 100

import os
from random import randint

from Compiler.types import *
from Compiler.library import if_, print_ln
from Compiler.comparison import PRandM, BitLTL as BitLT

def parse_bool(s: str) -> bool:
    return bool(int(s))

BITS = int(os.environ.get("BITS", 256)) # Number of random bits to produce.
KEYGEN = parse_bool(os.environ.get("KEYGEN", False)) # Run key generation.
REVEAL = parse_bool(os.environ.get("REVEAL", False)) # Reval output.
LOG2Q = int(os.environ.get("LOG2Q", 12)) # Lattice modulus bitlength.
LOG2P = int(os.environ.get("LOG2P", 8)) # Rounding modulus bitlength.
DIM = int(os.environ.get("DIM", 512)) # Lattice dimension.
DOUBLE = parse_bool(os.environ.get("DOUBLE", False)) # Run evaluation twice.
CHECK = parse_bool(os.environ.get("CHECK", False)) # Check result against cleartext computation.
OUTPUT = parse_bool(os.environ.get("OUTPUT", False)) # Write result to file.

log2q = LOG2Q # Lattice modulus.
log2p = LOG2P # Rounding modulus.
m = DIM # Lattice dimension
int_size = ((2**log2q - 1)**2 * m).bit_length() # Maximum integer size.

# Compute how many p-bit elements we need to generate a random element in the
# base ring.
kappa = program.security # Controls the statistical distance to the uniform distribution.
l = math.ceil((BITS + kappa) / log2p) # Number of p-bit elements required to fill up the target range.

if DOUBLE:
    l *= 2

print(f"q=2^{log2q}, p=2^{log2p}, m={m}, l={l}")
print(f"KEYGEN={KEYGEN}, REVEAL={REVEAL}, DOUBLE={DOUBLE}, CHECK={CHECK}, OUTPUT={OUTPUT}")

def crand():
    r = randint(0, 2**log2q-1)
    return cint(r)

def srand():
    return sint.get_random_int(log2q)

def trunc(a: sint, k: int, m1: int, m2: int) -> sint:
    """
    Truncate the top and bottom bits of the `k`-bit integer `a`. Returns the
    integer corresponding to the bits in the range `[m1:m2]`.
    """
    r_dprime, r_prime, r = sint(), sint(), [sint() for i in range(m2)]
    PRandM(r_dprime, r_prime, r, k, m2, kappa)
    c = (two_power(k-1) + a + two_power(m2) * r_dprime + r_prime).reveal()
    # Compute separate c_prime for m1 and m2.
    c1_prime, c2_prime = c % two_power(m1), c % two_power(m2)
    u1, u2 = sint(), sint()
    BitLT(u1, c1_prime, r[:m1], kappa), BitLT(u2, c2_prime, r, kappa)
    a1_prime, a2_prime = c1_prime - sint.bit_compose(r[:m1]) + two_power(m1) * u1, c2_prime - r_prime + two_power(m2) * u2
    return (a2_prime - a1_prime) / two_power(m1)

def compose(a: Array) -> sint:
    l = len(a)
    log2_p1 = log2q - log2p
    log2_p2 = 2 * log2p - log2q
    def shift(i):
        p1_shift = (i - 1) * log2_p1
        p2_shift = i * log2_p2
        return max(0, p1_shift + p2_shift)
    return sum(a[i] << shift(i) for i in range(l))

def key_gen(m: int):
    a = Matrix(l, m, cint)
    for i in range(l):
        for j in range(m):
            a[i][j] = crand()
            
    k = Array(m, sint)
    for i in range(m):
        k[i] = srand() if KEYGEN else sint(crand())
    
    return a, k

def eval(a: Matrix, k: Array):
    r = a * k
    
    # Modulo q and round p.
    for i in range(l):
        r[i] = trunc(r[i], int_size, log2q-log2p, log2q)
    
    if DOUBLE:
        l_half = l//2
        
        # Compose.
        r = [
            compose(r[:l_half]),
            compose(r[l_half:]),
        ]
    else:        
        # Compose.
        r = compose(r)
    
    return r

def eval_clear(a: Matrix, k: Array):
    k: Array = k.reveal()
    
    r = a * k
    
    def trunc(a: cint, k: int, m1: int, m2: int):
        a_bits = a.bit_decompose()
        return cint.bit_compose(a_bits[m1:m2])
    
    # Modulo q and round p.
    for i in range(l):
        r[i] = trunc(r[i], int_size, log2q-log2p, log2q)
    
    if DOUBLE:
        l_half = l//2
        
        # Compose.
        r = [
            compose(r[:l_half]),
            compose(r[l_half:]),
        ]
    else:        
        # Compose.
        r = compose(r)
    
    return r

def main():    
    a, k = key_gen(m)
    r = eval(a, k)
    if OUTPUT:
        sint.write_to_file(r)
    if REVEAL:
        print_ln("output = %s", r.reveal())
    if CHECK:
        r_clear = eval_clear(a, k)
        r_revealed = r.reveal()
        @if_(r_clear != r_revealed)
        def _():
            print_ln("r_clear    = %s", r_clear)
            print_ln("r_revealed = %s", r_revealed)
            print_ln("check failed")

main()
