from math import ceil, log2, log, gcd, floor
from Cryptodome.Hash import SHAKE128

from Compiler.library import else_, if_e, print_ln, start_timer, stop_timer
from Compiler import program
from Compiler.types import *


class HadesMimc:
    def __init__(self, p, t, use_squares):
        self.use_squares = use_squares
        self.p = p
        self.t = t
        self.d = HadesMimc.get_d(p)
        shake = HadesMimc.init_shake(p)

        n = p.bit_length()
        N = n * t
        self.Rf, self.Rp = HadesMimc.calc_round_numbers(N, t, self.d)
        assert(self.Rf & 1 == 0)
        self.rounds = self.Rf + self.Rp
        self.mds = self.compute_mds_matrix(shake)
        self.key_mds = self.compute_mds_matrix(shake)
        self.rc = self.gen_rc(self.rounds, shake)

    def print_depth(self):
        squares = 0
        depth = 0
        mul = 0
        if self.d == 3:
            if self.use_squares:
                squares = self.Rf * self.t + self.Rp
                mul = self.Rf * self.t + self.Rp
                depth = self.rounds + 1
            else:
                depth = self.rounds * 2
                mul = (self.Rf * self.t + self.Rp) * 2
        elif self.d == 5:
            if self.use_squares:
                squares = (self.Rf * self.t + self.Rp) * 2
                depth = self.rounds * 3
                mul = self.Rf * self.t + self.Rp
            else:
                depth = self.rounds * 3
                mul = (self.Rf * self.t + self.Rp) * 3
        else:
            assert(False)

        print_ln("Expected:")
        print_ln("  %s inverses", 0)
        print_ln("  %s squares", squares)
        print_ln("  %s muls", mul)
        print_ln("  %s depth", depth  + 1) # reveal included

    @staticmethod
    def get_d(p):
        for d in range(3, p):
            if gcd(d, p - 1) == 1:
                break
        return d

    @staticmethod
    def init_shake(p):
        bitlen = p.bit_length()
        num = ceil(bitlen / 64)

        shake = SHAKE128.new()
        shake.update('HadesMimc'.encode('ascii'))
        for i in range(num):
            prime_block = (p >> (i * 64)) & ((0x1 << 64) - 1)
            shake.update(int(prime_block).to_bytes(8, byteorder = 'little'))
        return shake

    def field_element_from_shake(self, shake):
        bitlen = self.p.bit_length()
        byte = ceil(bitlen / 8)
        word = ceil(byte / 8)

        while True:
            word_buf = [0] * word
            buf = shake.read(byte)
            for i in range(word):
                byte_array = [0] * 8
                for j in range(i * 8, min((i + 1) * 8, byte)):
                    byte_array[j - i * 8] = buf[j];
                word_buf[i] = int.from_bytes(byte_array, byteorder = 'little')
            res = 0
            for el in reversed(word_buf):
                res = (res << 64) + el
            if res < self.p:
                return res

    @staticmethod
    def __R_F_stat(N, t, R_F):
        ret_val = 6
        return (R_F >= ret_val)

    @staticmethod
    def __R_gcd(N, t, R_F, R_P):
        n = ceil(float(N) / t)
        p_est = 0x1 << int(n)
        return (R_F + R_P >= 4 + ceil(log(p_est, 3)) - floor(2 * log(n, 3)))

    @staticmethod
    def __R_grob_1(N, t, R_F, R_P):
        n = ceil(float(N) / t)
        p_est = 0x1 << int(n)
        return (R_F + R_P >= 2 + ceil(log(p_est, 3) / float(2)))

    @staticmethod
    def __R_grob_2(N, t, R_F, R_P):
        n = ceil(float(N) / t)
        p_est = 0x1 << int(n)
        return (R_F + R_P >= 2 + ceil(log(p_est, 3) / float(2))) # Same as R_grob_1


    @staticmethod
    def __R_inter(N, t, R_F, R_P):
        n = ceil(float(N) / t)
        p_est = 0x1 << int(n)
        return (R_F + R_P >= 4 + ceil(log(p_est, 3) / float(2)) + ceil(log(t, 3)))

    @staticmethod
    def __get_MPC_cost(R_F, R_P, t, d):
        return (d * float(R_P + t * R_F) + (1.0 - d) * float(R_P + R_F))


    @staticmethod
    def calc_round_numbers(N, t, d):
        R_P = 0
        R_F = 0
        min_cost = float("inf")
        # Brute-force approach
        for R_P_t in range(1, N):
            for R_F_t in range(1, 100):
                if R_F_t % 2 == 0:
                    cond_fulfilled =\
                        HadesMimc.__R_F_stat(N, t, R_F_t)\
                        and HadesMimc.__R_gcd(N, t, R_F_t, R_P_t)\
                        and HadesMimc.__R_grob_1(N, t, R_F_t, R_P_t)\
                        and HadesMimc.__R_grob_2(N, t, R_F_t, R_P_t)\
                        and HadesMimc.__R_inter(N, t, R_F_t, R_P_t)
                    if cond_fulfilled == True:
                        # Security fulfilled, check the cost
                        cost = HadesMimc.__get_MPC_cost(R_F_t, R_P_t, t, d)
                        # Check if (1) cost is reduced, or (2) cost is the same and depth is the same, but new R_F is smaller
                        if (cost < min_cost) or (cost == min_cost and ((R_F_t + R_P_t) == (R_F + R_P))and R_F_t < R_F):
                            R_P = ceil(R_P_t)
                            R_F = ceil(R_F_t)
                            min_cost = cost
        return (int(R_F), int(R_P))

    @staticmethod
    def xgcd(a, b):
        x0, x1, y0, y1 = 0, 1, 1, 0
        while a != 0:
            (q, a), b = divmod(b, a), a
            y0, y1 = y1, y0 - q * y1
            x0, x1 = x1, x0 - q * x1
        return b, x0, y0

    def compute_mds_matrix(self, shake):
        M = [[0]*t for _ in range(t)]

        # Sample random distinct indices and assign to xs and ys
        while True:
            flag = True
            rand_list = [self.field_element_from_shake(shake) for _ in range(0, 2 * self.t)]
            while len(rand_list) != len(set(rand_list)): # Check for duplicates
                rand_list = [self.field_element_from_shake(shake) for _ in range(0, 2 * self.t)]
            xs = rand_list[:self.t]
            ys = rand_list[self.t:]
            for i in range(0, self.t):
                for j in range(0, self.t):
                    s_ = (xs[i] + ys[j]) % self.p
                    if (flag == False) or (s_ == 0):
                        flag = False
                    else:
                        _, entry, _ = HadesMimc.xgcd(s_, self.p)
                        M[i][j] = entry % self.p
            if flag == False:
                continue
            return M

    def gen_rc(self, num, shake):
        round_constants = []
        for _ in range(num):
            rc = []
            for i in range(t):
               rc.append(self.field_element_from_shake(shake))
            round_constants.append(rc)
        return round_constants

    @staticmethod
    def mat_vector_mul(mat, vec):
        out = [None for i in range(len(mat))]
        for i in range(len(out)):
            out[i] = sum(mat[i][j] * vec[j] for j in range(len(vec)))
        return out

    def mat_vector_mul_plain(self, mat, vec):
        out = [None for i in range(len(mat))]
        for i in range(len(out)):
            out[i] = sum(mat[i][j] * vec[j] for j in range(len(vec))) % self.p
        return out

    @staticmethod
    def vec_add(vec1, vec2):
        out = sint.Array(len(vec1))
        for i in range(len(vec1)):
            out[i] = vec1[i] + vec2[i]
        return out

    def vec_add_plain(self, vec1, vec2):
        for i in range(len(vec1)):
            vec1[i] = (vec1[i] + vec2[i]) % self.p
        return vec1

    def keyschedule_plain(self, key):
        keys = []
        keys.append(key.copy())

        for i in range(self.rounds):
            subkey = self.mat_vector_mul_plain(self.key_mds, keys[i])
            subkey = self.vec_add_plain(subkey, self.rc[i])
            keys.append(subkey)
        return keys

    def sbox_plain(self, x):
        return pow(x, self.d, self.p)

    def encrypt_plain(self, plains, keys):
        state = plains.copy()

        r_f = self.Rf // 2

        for r in range(r_f):
            state = self.vec_add_plain(state, keys[r])
            for i in range(self.t):
                state[i] = self.sbox_plain(state[i])
            state = self.mat_vector_mul_plain(self.mds, state)

        for r in range(self.Rp):
            state = self.vec_add_plain(state, keys[r + r_f])
            state[0] = self.sbox_plain(state[0])
            state = self.mat_vector_mul_plain(self.mds, state)

        for r in range(r_f):
            state = self.vec_add_plain(state, keys[r + r_f + self.Rp])
            for i in range(self.t):
                state[i] = self.sbox_plain(state[i])
            state = self.mat_vector_mul_plain(self.mds, state)

        # final key add
        state = self.vec_add_plain(state, keys[self.Rf + self.Rp])
        return state

    def keyschedule(self, key):
        keys = []
        keys.append(key)

        for i in range(self.rounds):
            subkey = HadesMimc.mat_vector_mul(self.key_mds, keys[i])
            subkey = self.vec_add(subkey, self.rc[i])
            keys.append(subkey)
        return keys

    def compute_cube(self, x):
        if self.use_squares:
            r, rsq = sint.get_random_square()
            r_cube = r * rsq
            y = (x - r).reveal()
            return 3 * y * rsq + 3 * y ** 2 * r + y ** 3 + r_cube
        else:
            return x * x * x

    def sbox(self, x):
        if self.d == 3:
            return self.compute_cube(x)
        else:
            return x ** self.d

    def encrypt(self, plains, keys):
        state = plains.copy()

        r_f = self.Rf // 2

        for r in range(r_f):
            state = self.vec_add(state, keys[r])
            for i in range(self.t):
                state[i] = self.sbox(state[i])
            state = self.mat_vector_mul(self.mds, state)

        for r in range(self.Rp):
            state = self.vec_add(state, keys[r + r_f])
            state[0] = self.sbox(state[0])
            state = self.mat_vector_mul(self.mds, state)

        for r in range(r_f):
            state = self.vec_add(state, keys[r + r_f + self.Rp])
            for i in range(self.t):
                state[i] = self.sbox(state[i])
            state = self.mat_vector_mul(self.mds, state)

        # final key add
        state = self.vec_add(state, keys[self.Rf + self.Rp])
        return state


def plain(hadesmimc, mk, plaintext):
    rk = hadesmimc.keyschedule_plain(mk)
    ct = hadesmimc.encrypt_plain(plaintext, rk)
    return ct

def shared(hadesmimc, mk, plaintext):
    t = len(mk)
    mk_ = sint.Array(t)
    for i in range(t):
        mk_[i] = sint(mk[i])

    rk = hadesmimc.keyschedule(mk_)
    ct = hadesmimc.encrypt(plaintext, rk)
    return ct

def shared_wo_keyschedule(hadesmimc, mk, plaintext):
    t = len(mk)
    rk = hadesmimc.keyschedule_plain(mk)

    rk_ = []
    for r in rk:
        tmp = sint.Array(t)
        for i in range(t):
            tmp[i] = sint(r[i])
        rk_.append(tmp)

    ct = hadesmimc.encrypt(plaintext, rk_)
    return ct

def reveal(shared):
    res = []
    for s in shared:
        c = s.reveal()
        res.append(c)
    return res

def compare(a, b):
    if len(a) != len(b):
        return False
    t = len(a)
    correct = cint(0)
    for i in range(t):
        correct = correct + a[i] - b[i]

    @if_e(correct == 0)
    def _():
        print_ln("Correct")
    @else_
    def _():
        print_ln("A Error occured!?")

def main(t, shared_keyschedule, use_squares):
    p = program.prime
    l = p.bit_length()
    program.set_bit_length(l)
    print_ln("Prime %s with %s-bit", p, l)
    print_ln("Having %s plaintexts", t)

    hadesmimc = HadesMimc(p, t, use_squares)
    hadesmimc.print_depth()

    plaintext = [i for i in range(t)]
    key = [i * 3 for i in range(t)]
    ct = plain(hadesmimc, key, plaintext)

    if shared_keyschedule:
        print_ln("Running MPC with Shared Keyschedule")
        start_timer(1)
        ct_ = shared(hadesmimc, key, plaintext)
        ct_ = reveal(ct_)
        stop_timer(1)
        compare(ct, ct_)
    else:
        print_ln("Running MPC without Shared Keyschedule")
        start_timer(1)
        ct_ = shared_wo_keyschedule(hadesmimc, key, plaintext)
        ct_ = reveal(ct_)
        stop_timer(1)
        compare(ct, ct_)

# default
t = 5
shared_keyschedule = True
use_squares = False

args = len(program.args)
if args > 1:
    t = int(program.args[1])
if args > 2:
    use_squares = bool(int(program.args[2]))
if args > 3:
    shared_keyschedule = bool(int(program.args[3]))

if program.prime == None:
    print('Error: No prime provided')
    exit()

program.name = "hades_mimc"
print("Compiling: for")
print("Prime = " + str(program.prime))
print("t = " + str(t))
print("Shared KS = " + str(shared_keyschedule))
print("Using Squares = " + str(use_squares))
program.use_square(use_squares)
main(t, shared_keyschedule, use_squares)
