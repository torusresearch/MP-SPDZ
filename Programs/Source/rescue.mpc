from math import ceil, log2, gcd
from Cryptodome.Hash import SHAKE128

from Compiler.library import else_, if_e, print_ln, start_timer, stop_timer
from Compiler import program
from Compiler.types import *


class Rescue:
    def __init__(self, p, t, kappa, use_squares, precomputed_inverses=True):
        self.use_squares = use_squares
        self.precomputed_inverses = precomputed_inverses
        self.p = p
        self.t = t
        self.d, self.d_inv = Rescue.get_d(p)
        shake = Rescue.init_shake(p)

        self.rounds =  Rescue.calc_round_numbers(self.d, t, kappa)
        self.mds = self.compute_mds_matrix(shake)
        self.key_mds = self.compute_mds_matrix(shake)
        self.rc = self.gen_rc(2 * self.rounds + 1, shake)

    def print_depth(self, shared_keyschedule):
        squares = 0
        depth = 0
        mul = 0
        inverses = 0
        if self.d == 3:
            if self.use_squares:
                squares = self.rounds * 2 * t
                mul = self.rounds * t + self.rounds * t * 3
                depth = self.rounds + self.rounds * 2 + 2
            else:
                depth = self.rounds * 2 + self.rounds * 2 + 3
                mul = self.rounds * 2 * self.t + self.rounds * (2 + 2) * self.t
        elif self.d == 5:
            if self.use_squares:
                squares = self.rounds * 4 * t
                depth = self.rounds * 3 + self.rounds * 2 + 3
                mul = self.rounds * 3 * self.t + self.rounds * (3 + 2) * self.t - squares
            else:
                depth = self.rounds * 3 + self.rounds * 2 + 4
                mul = self.rounds * 3 * self.t + self.rounds * (3 + 2) * self.t
        else:
            assert(False)

        if self.precomputed_inverses:
            inverses = t * self.rounds
            mul = mul - inverses
            if not self.use_squares:
                depth = depth - 1 # already precomputed

        if shared_keyschedule:
            inverses = inverses * 2
            squares = squares * 2
            mul = mul * 2

        print_ln("Expected:")
        print_ln("  %s inverses", inverses)
        print_ln("  %s squares", squares)
        print_ln("  %s muls", mul)
        print_ln("  %s depth", depth  + 1) # reveal included

    @staticmethod
    def xgcd(a, b):
        x0, x1, y0, y1 = 0, 1, 1, 0
        while a != 0:
            (q, a), b = divmod(b, a), a
            y0, y1 = y1, y0 - q * y1
            x0, x1 = x1, x0 - q * x1
        return b, x0, y0

    @staticmethod
    def get_d(p):
        for d in range(3, p):
            if gcd(d, p - 1) == 1:
                break
        _, d_inv, _ = Rescue.xgcd(d, p - 1)
        while d_inv < 0:
            d_inv = d_inv + p - 1
        return d, d_inv

    @staticmethod
    def init_shake(p):
        bitlen = p.bit_length()
        num = ceil(bitlen / 64)

        shake = SHAKE128.new()
        shake.update('Rescue'.encode('ascii'))
        for i in range(num):
            prime_block = (p >> (i * 64)) & ((0x1 << 64) - 1)
            shake.update(int(prime_block).to_bytes(8, byteorder = 'little'))
        return shake

    def field_element_from_shake(self, shake):
        bitlen = self.p.bit_length()
        byte = ceil(bitlen / 8)
        word = ceil(byte / 8)

        while True:
            word_buf = [0] * word
            buf = shake.read(byte)
            for i in range(word):
                byte_array = [0] * 8
                for j in range(i * 8, min((i + 1) * 8, byte)):
                    byte_array[j - i * 8] = buf[j];
                word_buf[i] = int.from_bytes(byte_array, byteorder = 'little')
            res = 0
            for el in reversed(word_buf):
                res = (res << 64) + el
            if res < self.p:
                return res

    @staticmethod
    def calc_round_numbers(d, t, kappa):
        if (d == 3):
            return max(10, 2 * ceil((kappa + 2) / (4 * t)))
        else:
            return max(10, 2 * ceil((kappa + 3) / (5.5 * t)))

    def compute_mds_matrix(self, shake):
        M = [[0]*t for _ in range(t)]

        # Sample random distinct indices and assign to xs and ys
        while True:
            flag = True
            rand_list = [self.field_element_from_shake(shake) for _ in range(0, 2 * self.t)]
            while len(rand_list) != len(set(rand_list)): # Check for duplicates
                rand_list = [self.field_element_from_shake(shake) for _ in range(0, 2 * self.t)]
            xs = rand_list[:self.t]
            ys = rand_list[self.t:]
            for i in range(0, self.t):
                for j in range(0, self.t):
                    s_ = (xs[i] + ys[j]) % self.p
                    if (flag == False) or (s_ == 0):
                        flag = False
                    else:
                        # entry = pow(s_, -1, self.p)
                        _, entry, _ = Rescue.xgcd(s_, self.p)
                        M[i][j] = entry % self.p
            if flag == False:
                continue
            return M

    def gen_rc(self, num, shake):
        round_constants = []
        for _ in range(num):
            rc = []
            for i in range(t):
               rc.append(self.field_element_from_shake(shake))
            round_constants.append(rc)
        return round_constants

    @staticmethod
    def mat_vector_mul(mat, vec):
        out = [None for i in range(len(mat))]
        for i in range(len(out)):
            out[i] = sum(mat[i][j] * vec[j] for j in range(len(vec)))
        return out

    def mat_vector_mul_plain(self, mat, vec):
        out = [None for i in range(len(mat))]
        for i in range(len(out)):
            out[i] = sum(mat[i][j] * vec[j] for j in range(len(vec))) % self.p
        return out

    @staticmethod
    def vec_add(vec1, vec2):
        out = sint.Array(len(vec1))
        for i in range(len(vec1)):
            out[i] = vec1[i] + vec2[i]
        return out

    def vec_add_plain(self, vec1, vec2):
        for i in range(len(vec1)):
            vec1[i] = (vec1[i] + vec2[i]) % self.p
        return vec1

    def compute_cube(self, x):
        if self.use_squares:
            r, rsq = sint.get_random_square()
            r_cube = r * rsq
            y = (x - r).reveal()
            return 3 * y * rsq + 3 * y ** 2 * r + y ** 3 + r_cube
        else:
            return x * x * x

    def forward_power_plain(self, x):
        return pow(x, self.d, self.p)

    def backward_power_plain(self, x):
        return pow(x, self.d_inv, self.p)

    def keyschedule_plain(self, key):
        keys = []
        key_state = key.copy()

        key_injection = self.rc[0]
        key_state = self.vec_add_plain(key_state, key_injection)
        keys.append(key_state.copy())

        for r in range(1, 2 * self.rounds + 1):
            if r % 2 == 1:
                for i in range(self.t):
                    key_state[i] = self.backward_power_plain(key_state[i])
            else:
                for i in range(self.t):
                    key_state[i] = self.forward_power_plain(key_state[i])

            key_injection = self.mat_vector_mul_plain(self.key_mds, key_injection)
            key_injection = self.vec_add_plain(key_injection, self.rc[r])

            key_state = self.mat_vector_mul_plain(self.mds, key_state)
            key_state = self.vec_add_plain(key_state, key_injection)

            keys.append(key_state.copy())
        return keys

    def encrypt_plain(self, plains, key):
        state = plains.copy()
        key_state = key.copy()

        key_injection = self.rc[0]
        key_state = self.vec_add_plain(key_state, key_injection)
        state = self.vec_add_plain(state, key_state)

        for r in range(1, 2 * self.rounds + 1):
            if r % 2 == 1:
                for i in range(self.t):
                    key_state[i] = self.backward_power_plain(key_state[i])
                    state[i] = self.backward_power_plain(state[i])
            else:
                for i in range(self.t):
                    key_state[i] = self.forward_power_plain(key_state[i])
                    state[i] = self.forward_power_plain(state[i])

            key_injection = self.mat_vector_mul_plain(self.key_mds, key_injection)
            key_injection = self.vec_add_plain(key_injection, self.rc[r])

            key_state = self.mat_vector_mul_plain(self.mds, key_state)
            key_state = self.vec_add_plain(key_state, key_injection)

            state = self.mat_vector_mul_plain(self.mds, state)
            state = self.vec_add_plain(state, key_state)

        return list(state)

    def forward_power(self, x):
        if self.d == 3:
            return self.compute_cube(x)
        else:
            return x ** self.d

    def random_shared_inverse_tuple(self, ):
        if self.precomputed_inverses:
            t = sint.get_random_inverse()
            return t[0], t[1]
        else:
            t = sint.get_random_triple()
            r1 = t[0]
            r2 = t[1]
            product = t[2].reveal()
            # TODO prdouct = zero prob!
            return r1, r2 * (1 / product)

    def backward_power(self, x):
        r, r_inv = self.random_shared_inverse_tuple()
        r_exp = self.forward_power(r)

        c = (x * r_exp).reveal()
        c = c ** cint(self.d_inv)
        return c * r_inv

    def encrypt(self, plains, key):
        state = plains.copy()
        key_state = key

        key_injection = self.rc[0]
        key_state = self.vec_add(key_state, key_injection)
        state = self.vec_add(state, key_state)

        for r in range(1, 2 * self.rounds + 1):
            if r % 2 == 1:
                for i in range(self.t):
                    key_state[i] = self.backward_power(key_state[i])
                    state[i] = self.backward_power(state[i])
            else:
                for i in range(self.t):
                    key_state[i] = self.forward_power(key_state[i])
                    state[i] = self.forward_power(state[i])

            key_injection = self.mat_vector_mul(self.key_mds, key_injection)
            key_injection = self.vec_add(key_injection, self.rc[r])

            key_state = self.mat_vector_mul(self.mds, key_state)
            key_state = self.vec_add(key_state, key_injection)

            state = self.mat_vector_mul(self.mds, state)
            state = self.vec_add(state, key_state)

        return list(state)

    def encrypt_with_roundkeys(self, plains, keys):
        state = plains.copy()

        state = self.vec_add(state, keys[0])

        for r in range(1, 2 * self.rounds + 1):
            if r % 2 == 1:
                for i in range(self.t):
                    state[i] = self.backward_power(state[i])
            else:
                pass
                for i in range(self.t):
                    state[i] = self.forward_power(state[i])

            state = self.mat_vector_mul(self.mds, state)
            state = self.vec_add(state, keys[r])

        return list(state)


def plain(rescue, mk, plaintext):
    ct = rescue.encrypt_plain(plaintext, mk)
    return ct

def shared(rescue, mk, plaintext):
    t = len(mk)
    mk_ = sint.Array(t)
    for i in range(t):
        mk_[i] = sint(mk[i])

    ct = rescue.encrypt(plaintext, mk_)
    return ct

def shared_wo_keyschedule(rescue, mk, plaintext):
    t = len(mk)
    rk = rescue.keyschedule_plain(mk)

    rk_ = []
    for r in rk:
        tmp = sint.Array(t)
        for i in range(t):
            tmp[i] = sint(r[i])
        rk_.append(tmp)

    ct = rescue.encrypt_with_roundkeys(plaintext, rk_)
    return ct

def reveal(shared):
    res = []
    for s in shared:
        c = s.reveal()
        res.append(c)
    return res

def compare(a, b):
    if len(a) != len(b):
        return False
    t = len(a)
    correct = cint(0)
    for i in range(t):
        correct = correct + a[i] - b[i]

    @if_e(correct == 0)
    def _():
        print_ln("Correct")
    @else_
    def _():
        print_ln("A Error occured!?")

def main(t, shared_keyschedule, use_squares):
    p = program.prime
    l = p.bit_length()
    program.set_bit_length(l)
    print_ln("Prime %s with %s-bit", p, l)
    print_ln("Having %s plaintexts", t)

    rescue = Rescue(p, t, 128, use_squares)
    rescue.print_depth(shared_keyschedule)

    plaintext = [i for i in range(t)]
    key = [i * 3 for i in range(t)]
    ct = plain(rescue, key, plaintext)

    if shared_keyschedule:
        print_ln("Running MPC with Shared Keyschedule")
        start_timer(1)
        ct_ = shared(rescue, key, plaintext)
        ct_ = reveal(ct_)
        stop_timer(1)
        compare(ct, ct_)
    else:
        print_ln("Running MPC without Shared Keyschedule")
        start_timer(1)
        ct_ = shared_wo_keyschedule(rescue, key, plaintext)
        ct_ = reveal(ct_)
        stop_timer(1)
        compare(ct, ct_)

# default
t = 5
shared_keyschedule = True
use_squares = False

args = len(program.args)
if args > 1:
    t = int(program.args[1])
if args > 2:
    use_squares = bool(int(program.args[2]))
if args > 3:
    shared_keyschedule = bool(int(program.args[3]))

if program.prime == None:
    print('Error: No prime provided')
    exit()

program.name = "rescue"
print("Compiling: for")
print("Prime = " + str(program.prime))
print("t = " + str(t))
print("Shared KS = " + str(shared_keyschedule))
print("Using Squares = " + str(use_squares))
program.use_square(use_squares)
main(t, shared_keyschedule, use_squares)
